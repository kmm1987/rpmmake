From a218f4865a258e1cd8da9ad7fe210a97b4d08108 Mon Sep 17 00:00:00 2001
From: loongson Buildteam <buildteam@loongson.org>
Date: Tue, 12 Apr 2022 17:10:45 +0800
Subject: [PATCH] LoongArch64 support boot parameter 01002 version


diff --git a/conf/Makefile.common b/conf/Makefile.common
index d8cc61d..27cadba 100644
--- a/conf/Makefile.common
+++ b/conf/Makefile.common
@@ -21,8 +21,8 @@ if COND_powerpc_ieee1275
   CFLAGS_PLATFORM += -mcpu=powerpc
 endif
 if COND_loongarch64
-  CFLAGS_PLATFORM += -fno-strict-aliasing -march=loongarch64 -mabi=lp64 -fno-plt -Wa,-mla-global-with-pcrel
-  CPPFLAGS_PLATFORM = -fno-strict-aliasing -march=loongarch64 -mabi=lp64 -fno-plt -Wa,-mla-global-with-pcrel
+  CFLAGS_PLATFORM += -fno-strict-aliasing -march=loongarch64 -mabi=lp64 -fno-plt -Wa,-mla-global-with-abs -mcmodel=large
+  CPPFLAGS_PLATFORM = -fno-strict-aliasing -march=loongarch64 -mabi=lp64 -fno-plt -Wa,-mla-global-with-abs -mcmodel=large
 endif
 
 # Other options
diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 666f87a..ee3c56f 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -330,7 +330,6 @@ kernel = {
   loongarch64 = kern/generic/rtc_get_time_ms.c;
   loongarch64_efi = kern/loongarch64/efi/init.c;
   loongarch64_efi = lib/loongarch64/efi/loongson.c;
-  loongarch64_efi = lib/loongarch64/efi/loongson_asm.S;
 
   powerpc_ieee1275 = kern/powerpc/cache.S;
   powerpc_ieee1275 = kern/powerpc/dl.c;
diff --git a/grub-core/kern/elfXX.c b/grub-core/kern/elfXX.c
index 8b1dce9..1859d18 100644
--- a/grub-core/kern/elfXX.c
+++ b/grub-core/kern/elfXX.c
@@ -134,12 +134,6 @@ grub_elfXX_load (grub_elf_t elf, const char *filename,
 	load_addr &= 0x3FFFFFFFFFFFFFFFULL;
 	break;
       }
-#ifdef GRUB_CPU_LOONGARCH64
-    grub_uint64_t addr;
-    asm volatile ("csrrd %0, 0x181" : "=r" (addr));
-    if ((load_addr >> 48) != (addr >> 48))
-      return grub_error (GRUB_ERR_BAD_OS, "bad address space");
-#endif
     load_addr += (grub_addr_t) load_offset;
 
     if (load_addr < load_base)
diff --git a/grub-core/lib/loongarch64/efi/loongson.c b/grub-core/lib/loongarch64/efi/loongson.c
index 8b60d82..3c6c322 100644
--- a/grub-core/lib/loongarch64/efi/loongson.c
+++ b/grub-core/lib/loongarch64/efi/loongson.c
@@ -23,400 +23,14 @@
 #include <grub/cpu/memory.h>
 #include <grub/machine/loongson.h>
 
-#define loongson_params (&loongson_boot_params->boot_params.efi.smbios.lp)
-#define loongson_boot_params_size ALIGN_UP (sizeof (*loongson_boot_params), 8)
-#define loongson_reset_code_size (&grub_efi_loongson_reset_end - &grub_efi_loongson_reset_start)
-
-extern grub_uint8_t grub_efi_loongson_reset_start;
-extern grub_uint8_t grub_efi_loongson_reset_end;
-
-static struct
-{
-  grub_efi_loongson_boot_params boot_params;
-  grub_efi_loongson_memory_map memory_map;
-  grub_efi_loongson_cpu_info cpu_info;
-  grub_efi_loongson_system_info system_info;
-  grub_efi_loongson_irq_src_routing_table irq_src_routing_table;
-  grub_efi_loongson_interface_info interface_info;
-  grub_efi_loongson_special_attribute special_attribute;
-  grub_efi_loongson_board_devices board_devices;
-} GRUB_PACKED
-* loongson_boot_params;
-
-static void
-grub_efi_loongson_init_reset_system (void)
-{
-  grub_efi_loongson_boot_params *boot_params;
-  grub_uint8_t *reset_code_addr = (grub_uint8_t *) loongson_boot_params +
-                                  loongson_boot_params_size;
-
-  boot_params = &loongson_boot_params->boot_params;
-  grub_efi_loongson_reset_system_addr =
-                 (grub_uint64_t) grub_efi_system_table->runtime_services->reset_system;
-  grub_memcpy (reset_code_addr, &grub_efi_loongson_reset_start, loongson_reset_code_size);
-  grub_arch_sync_caches (reset_code_addr, loongson_reset_code_size);
-
-  boot_params->reset_system.reset_cold = (grub_uint64_t) reset_code_addr +
-                                         ((grub_uint64_t) &grub_efi_loongson_reset_cold -
-                                          (grub_uint64_t) &grub_efi_loongson_reset_start);
-  boot_params->reset_system.reset_warm = (grub_uint64_t) reset_code_addr +
-                                         ((grub_uint64_t) &grub_efi_loongson_reset_warm -
-                                          (grub_uint64_t) &grub_efi_loongson_reset_start);
-  boot_params->reset_system.shutdown = (grub_uint64_t) reset_code_addr +
-                                         ((grub_uint64_t) &grub_efi_loongson_reset_shutdown -
-                                          (grub_uint64_t) &grub_efi_loongson_reset_start);
-  boot_params->reset_system.do_suspend = (grub_uint64_t) reset_code_addr +
-                                         ((grub_uint64_t) &grub_efi_loongson_reset_suspend -
-                                          (grub_uint64_t) &grub_efi_loongson_reset_start);
-}
-
-static void
-grub_efi_loongson_init_smbios (grub_efi_loongson_smbios_table *smbios_table)
-{
-  grub_efi_loongson_smbios_table *dst = &loongson_boot_params->boot_params.efi.smbios;
-
-  dst->vers = smbios_table->vers;
-  dst->vga_bios = smbios_table->vga_bios;
-}
-
-static void
-grub_efi_loongson_init_cpu_info (grub_efi_loongson_smbios_table *smbios_table)
-{
-  grub_efi_loongson_cpu_info *src = (void *) smbios_table->lp.cpu_offset;
-  grub_efi_loongson_cpu_info *dst = &loongson_boot_params->cpu_info;
-
-  if (!src)
-    return;
-
-  grub_memcpy (dst, src, sizeof (grub_efi_loongson_cpu_info));
-  loongson_params->cpu_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
-}
-
-static void
-grub_efi_loongson_init_system_info (grub_efi_loongson_smbios_table *smbios_table)
-{
-  grub_efi_loongson_system_info *src = (void *) smbios_table->lp.system_offset;
-  grub_efi_loongson_system_info *dst = &loongson_boot_params->system_info;
-
-  if (!src)
-    return;
-
-  grub_memcpy (dst, src, sizeof (grub_efi_loongson_system_info));
-  loongson_params->system_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
-}
-
-static void
-grub_efi_loongson_init_irq_src_routing_table (grub_efi_loongson_smbios_table *smbios_table)
-{
-  grub_efi_loongson_irq_src_routing_table *src = (void *) smbios_table->lp.irq_offset;
-  grub_efi_loongson_irq_src_routing_table *dst = &loongson_boot_params->irq_src_routing_table;
-
-  if (!src)
-    return;
-
-  grub_memcpy (dst, src, sizeof (grub_efi_loongson_irq_src_routing_table));
-  loongson_params->irq_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
-}
-
-static void
-grub_efi_loongson_init_interface_info (grub_efi_loongson_smbios_table *smbios_table)
-{
-  grub_efi_loongson_interface_info *src = (void *) smbios_table->lp.interface_offset;
-  grub_efi_loongson_interface_info *dst = &loongson_boot_params->interface_info;
-
-  if (!src)
-    return;
-
-  grub_memcpy (dst, src, sizeof (grub_efi_loongson_interface_info));
-  loongson_params->interface_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
-}
-
-static void
-grub_efi_loongson_init_special_attribute (grub_efi_loongson_smbios_table *smbios_table)
-{
-  grub_efi_loongson_special_attribute *src = (void *) smbios_table->lp.special_offset;
-  grub_efi_loongson_special_attribute *dst = &loongson_boot_params->special_attribute;
-
-  if (!src)
-    return;
-
-  grub_memcpy (dst, src, sizeof (grub_efi_loongson_special_attribute));
-  loongson_params->special_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
-}
-
-static void
-grub_efi_loongson_init_board_devices (grub_efi_loongson_smbios_table *smbios_table)
-{
-  grub_efi_loongson_board_devices *src = (void *) smbios_table->lp.boarddev_table_offset;
-  grub_efi_loongson_board_devices *dst = &loongson_boot_params->board_devices;
-
-  if (!src)
-    return;
-
-  grub_memcpy (dst, src, sizeof (grub_efi_loongson_board_devices));
-  loongson_params->boarddev_table_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
-}
-
-#define ADD_MEMORY_DESCRIPTOR(desc, size)	\
-  ((grub_efi_memory_descriptor_t *) ((char *) (desc) + (size)))
-
-static void
-grub_efi_loongson_init_memory_map (grub_efi_loongson_smbios_table *smbios_table,
-                                   grub_efi_memory_descriptor_t *mmap_buf,
-                                   grub_efi_uintn_t mmap_size,
-                                   grub_efi_uintn_t desc_size)
-{
-  grub_efi_loongson_memory_map *src = (void *) smbios_table->lp.memory_offset;
-  grub_efi_loongson_memory_map *dst = &loongson_boot_params->memory_map;
-  grub_efi_memory_descriptor_t *mmap_end;
-  grub_efi_memory_descriptor_t *desc;
-  grub_efi_memory_descriptor_t *desc_next;
-  grub_efi_uint32_t mem_types_reserved[] =
-    {
-      1, // GRUB_EFI_RESERVED_MEMORY_TYPE
-      0, // GRUB_EFI_LOADER_CODE
-      0, // GRUB_EFI_LOADER_DATA
-      0, // GRUB_EFI_BOOT_SERVICES_CODE
-      0, // GRUB_EFI_BOOT_SERVICES_DATA
-      1, // GRUB_EFI_RUNTIME_SERVICES_CODE
-      1, // GRUB_EFI_RUNTIME_SERVICES_DATA
-      0, // GRUB_EFI_CONVENTIONAL_MEMORY
-      1, // GRUB_EFI_UNUSABLE_MEMORY
-      0, // GRUB_EFI_ACPI_RECLAIM_MEMORY
-      0, // GRUB_EFI_ACPI_MEMORY_NVS
-      1, // GRUB_EFI_MEMORY_MAPPED_IO
-      1, // GRUB_EFI_MEMORY_MAPPED_IO_PORT_SPACE
-      1, // GRUB_EFI_PAL_CODE
-      1, // GRUB_EFI_PERSISTENT_MEMORY
-    };
-  grub_uint32_t need_sort = 1;
-
-  if (!src)
-    return;
-
-  dst->vers = src->vers;
-  dst->nr_map = 0;
-  dst->mem_freq = src->mem_freq;
-  loongson_params->memory_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
-
-  if (!mmap_buf || !mmap_size || !desc_size)
-    return;
-
-  mmap_end = ADD_MEMORY_DESCRIPTOR (mmap_buf, mmap_size);
-
-  /* drop reserved */
-  for (desc = mmap_buf,
-       desc_next = desc;
-       desc < mmap_end;
-       desc = ADD_MEMORY_DESCRIPTOR (desc, desc_size))
-    {
-      desc->type = mem_types_reserved[desc->type];
-      if (desc->type)
-        continue;
-
-      if (desc != desc_next)
-        *desc_next = *desc;
-      desc_next = ADD_MEMORY_DESCRIPTOR (desc_next, desc_size);
-    }
-  mmap_end = desc_next;
-
-  /* sort: low->high */
-  while (need_sort)
-    {
-      need_sort = 0;
-
-      for (desc = mmap_buf,
-           desc_next = ADD_MEMORY_DESCRIPTOR (desc, desc_size);
-           (desc < mmap_end) && (desc_next < mmap_end);
-           desc = desc_next,
-           desc_next = ADD_MEMORY_DESCRIPTOR (desc, desc_size))
-        {
-          grub_efi_memory_descriptor_t tmp;
-
-          if (desc->physical_start <= desc_next->physical_start)
-            continue;
-
-          tmp = *desc;
-          *desc = *desc_next;
-          *desc_next = tmp;
-          need_sort = 1;
-        }
-    }
-
-  /* combine continuous memory map */
-  for (desc = mmap_buf,
-       desc_next = ADD_MEMORY_DESCRIPTOR (desc, desc_size);
-       desc_next < mmap_end;
-       desc_next = ADD_MEMORY_DESCRIPTOR (desc_next, desc_size))
-    {
-      grub_efi_physical_address_t prev_end = desc->physical_start + (desc->num_pages << 12);
-
-      if (prev_end == desc_next->physical_start)
-        {
-          desc->num_pages += desc_next->num_pages;
-          continue;
-        }
-
-      desc = ADD_MEMORY_DESCRIPTOR (desc, desc_size);
-      grub_memcpy (desc, desc_next, desc_size);
-    }
-  mmap_end = ADD_MEMORY_DESCRIPTOR (desc, desc_size);
-
-  /* write to loongson memory map */
-  for (desc = mmap_buf;
-       desc < mmap_end;
-       desc = ADD_MEMORY_DESCRIPTOR (desc, desc_size))
-    {
-      grub_efi_physical_address_t physical_start = grub_vtop ((void *) desc->physical_start);
-      grub_efi_physical_address_t physical_end = physical_start + (desc->num_pages << 12);
-
-      physical_start = ALIGN_UP (physical_start, 0x100000);
-      physical_end = ALIGN_DOWN (physical_end, 0x100000);
-
-      if (physical_start >= physical_end || (physical_end - physical_start) < 0x100000)
-        continue;
-
-      dst->map[dst->nr_map].node_id = (desc->physical_start >> 44) & 0xf;
-      dst->map[dst->nr_map].mem_type = GRUB_EFI_LOONGSON_SYSTEM_RAM;
-      dst->map[dst->nr_map].mem_start = physical_start;
-      dst->map[dst->nr_map].mem_size = (physical_end - physical_start) >> 20;
-
-      grub_dprintf ("loongson", "memory map %03u: 0x%016lx 0x%016lx @ %u\n",
-                    dst->nr_map, physical_start, physical_end - physical_start,
-                    dst->map[dst->nr_map].node_id);
-
-      dst->nr_map ++;
-    }
-}
-
-#define BYTES_TO_PAGES(bytes)	(((bytes) + 0xfff) >> 12)
-#define SUB_MEMORY_DESCRIPTOR(desc, size)	\
-  ((grub_efi_memory_descriptor_t *) ((char *) (desc) - (size)))
-
-void
-grub_efi_loongson_alloc_boot_params (void)
-{
-  grub_efi_memory_descriptor_t *mmap_buf;
-  grub_efi_memory_descriptor_t *mmap_end;
-  grub_efi_memory_descriptor_t *desc;
-  grub_efi_uintn_t mmap_size;
-  grub_efi_uintn_t desc_size;
-  grub_efi_physical_address_t address;
-  grub_efi_allocate_type_t type;
-  grub_efi_uintn_t pages;
-  grub_efi_status_t status;
-  grub_efi_boot_services_t *b;
-  int mm_status;
-
-  type = GRUB_EFI_ALLOCATE_ADDRESS;
-  pages = BYTES_TO_PAGES (loongson_boot_params_size + loongson_reset_code_size);
-
-  mmap_size = (1 << 12);
-  mmap_buf = grub_malloc (mmap_size);
-  if (!mmap_buf)
-    grub_fatal ("out of memory!");
-
-  mm_status = grub_efi_get_memory_map (&mmap_size, mmap_buf, 0, &desc_size, 0);
-  if (mm_status == 0)
-    {
-      grub_free (mmap_buf);
-      mmap_size += desc_size * 32;
-
-      mmap_buf = grub_malloc (mmap_size);
-      if (!mmap_buf)
-        grub_fatal ("out of memory!");
-
-      mm_status = grub_efi_get_memory_map (&mmap_size, mmap_buf, 0, &desc_size, 0);
-    }
-
-  if (mm_status < 0)
-    grub_fatal ("cannot get memory map!");
-
-  mmap_end = ADD_MEMORY_DESCRIPTOR (mmap_buf, mmap_size);
-
-  for (desc = SUB_MEMORY_DESCRIPTOR (mmap_end, desc_size);
-       desc >= mmap_buf;
-       desc = SUB_MEMORY_DESCRIPTOR (desc, desc_size))
-    {
-      if (desc->type != GRUB_EFI_CONVENTIONAL_MEMORY)
-        continue;
-      if (desc->physical_start >= grub_efi_max_usable_address())
-        continue;
-      if (desc->num_pages < pages)
-        continue;
-
-      address = desc->physical_start;
-      break;
-    }
-
-  grub_free (mmap_buf);
-
-  b = grub_efi_system_table->boot_services;
-  status = efi_call_4 (b->allocate_pages, type, GRUB_EFI_RUNTIME_SERVICES_DATA, pages, &address);
-  if (status != GRUB_EFI_SUCCESS)
-    grub_fatal ("cannot allocate Loongson boot parameters!");
-
-  loongson_boot_params = (void *) ((grub_addr_t) address);
-}
-
-void
-grub_efi_loongson_free_boot_params (void)
-{
-  grub_efi_free_pages ((grub_addr_t) loongson_boot_params,
-                       BYTES_TO_PAGES (loongson_boot_params_size + loongson_reset_code_size));
-}
-
-void *
-grub_efi_loongson_get_smbios_table (void)
+int
+grub_efi_get_bpi_version (const char *str)
 {
-  static grub_efi_loongson_smbios_table *smbios_table; 
-  grub_efi_loongson_boot_params *old_boot_params;
-  struct bootparamsinterface* boot_params;
-  void * tmp_boot_params = NULL;	
-  char * p = NULL;
-  if(smbios_table)
-    return smbios_table;
+  unsigned long version = GRUB_EFI_BPI_VER_NONE;
 
-  tmp_boot_params = grub_efi_loongson_get_boot_params();
-  if(tmp_boot_params == NULL)
-  {
-    grub_dprintf("loongson", "tmp_boot_params is NULL\n");
-    return tmp_boot_params;
-  }
- 
-  boot_params = (struct bootparamsinterface *)tmp_boot_params;
-  p = (char *)&(boot_params->signature);
-  if(grub_strncmp(p, "BPI", 3) == 0)
-  {
-    grub_dprintf("loongson", "find new bpi\n");
-    return boot_params ? boot_params : 0;
-  }
-  else
-  {
-    old_boot_params = (grub_efi_loongson_boot_params *)tmp_boot_params;
-    /*
-    {
-    	grub_dprintf("loongson", "smbios addr%llx\n", &old_boot_params->efi.smbios);
-    	grub_dprintf("loongson", "smbios vers%d\n", (grub_uint16_t)(&old_boot_params->efi.smbios.vers));
-    	grub_dprintf("loongson", "smbios vga_bios%d\n", &old_boot_params->efi.smbios.vga_bios);
-    	grub_dprintf("loongson", "lp memory offset %llx\n", &old_boot_params->efi.smbios.lp.memory_offset);
-    	grub_dprintf("loongson", "lp cpu offset %llx\n", &old_boot_params->efi.smbios.lp.cpu_offset);
-    	grub_dprintf("loongson", "lp system offset %llx\n", &old_boot_params->efi.smbios.lp.system_offset);
-    	grub_dprintf("loongson", "lp irq offset %llx\n", &old_boot_params->efi.smbios.lp.irq_offset);
-    	grub_dprintf("loongson", "lp interface offset %llx\n", &old_boot_params->efi.smbios.p.interface_offset);
-    	grub_dprintf("loongson", "lp special offset %llx\n", &old_boot_params->efi.smbios.lp.special_offset);
-    	grub_dprintf("loongson", "lp boarddev table offset %llx\n", &old_boot_params->efi.smbios.lp.boarddev_table_offset);
-    }
-    */
-    return old_boot_params ? &old_boot_params->efi.smbios : 0;
-  }
-
-}
+  version = grub_strtoul (str + 4, 0, 0);
 
-int
-grub_efi_is_loongson (void)
-{
-  return grub_efi_loongson_get_smbios_table () ? 1 : 0;
+  return version;
 }
 
 void *
@@ -424,20 +38,20 @@ grub_efi_loongson_get_boot_params (void)
 {
   static void * boot_params = NULL;
   grub_efi_configuration_table_t *tables;
-  grub_efi_guid_t smbios_guid = GRUB_EFI_LOONGSON_SMBIOS_TABLE_GUID;
+  grub_efi_guid_t loongson_bpi_guid = GRUB_EFI_LOONGSON_BPI_TABLE_GUID;
   unsigned int i;
 
   if (boot_params)
     return boot_params;
 
-  /* Look for Loongson SMBIOS in UEFI config tables. */
+  /* Look for Loongson boot params interface in UEFI config tables. */
   tables = grub_efi_system_table->configuration_table;
 
   for (i = 0; i < grub_efi_system_table->num_table_entries; i++)
-    if (grub_memcmp (&tables[i].vendor_guid, &smbios_guid, sizeof (smbios_guid)) == 0)
+    if (grub_memcmp (&tables[i].vendor_guid, &loongson_bpi_guid, sizeof (loongson_bpi_guid)) == 0)
       {
         boot_params= tables[i].vendor_table;
-        grub_dprintf ("loongson", "found registered SMBIOS @ %p\n", boot_params);
+        grub_dprintf ("loongson", "found registered BPI @ %p\n", boot_params);
         break;
       }
   return boot_params;
@@ -467,8 +81,9 @@ grub_efi_loongson_grub_calculatechecksum8 (const grub_uint8_t *buffer, grub_efi_
 }
 
 
-grub_uint32_t 
-grub_efi_loongson_memmap_sort(struct memmap array[], grub_uint32_t length, mem_map * bpmem, grub_uint32_t index, grub_uint32_t memtype)
+grub_uint32_t
+grub_efi_loongson_memmap_v1_sort(struct memmap_v1 array[], grub_uint32_t length,
+		mem_map_v1 * bpmem, grub_uint32_t index, grub_uint32_t memtype)
 {
   grub_uint64_t tempmemsize = 0;
   grub_uint32_t j = 0;
@@ -479,19 +94,19 @@ grub_efi_loongson_memmap_sort(struct memmap array[], grub_uint32_t length, mem_m
     tempmemsize = array[j].memsize;
     for(t = j + 1; t < length; t++)
     {
-      if(array[j].memstart + tempmemsize == array[t].memstart) 
+      if(array[j].memstart + tempmemsize == array[t].memstart)
       {
         tempmemsize += array[t].memsize;
       }
       else
-      {            
+      {
         break;
       }
    }
    bpmem->map[index].memtype = memtype;
    bpmem->map[index].memstart = array[j].memstart;
    bpmem->map[index].memsize = tempmemsize;
-   grub_dprintf("loongson", "map[%d]:type %x, start 0x%llx, end 0x%llx\n",
+   grub_dprintf("loongson", "v1 map[%d]:type %x, start 0x%llx, end 0x%llx\n",
 		   index,
 		   bpmem->map[index].memtype,
 		   bpmem->map[index].memstart,
@@ -503,3 +118,42 @@ grub_efi_loongson_memmap_sort(struct memmap array[], grub_uint32_t length, mem_m
   return index;
 }
 
+grub_uint32_t
+grub_efi_loongson_memmap_v3_sort(struct memmap_v3 array[], grub_uint32_t length,
+		mem_map_v3 * bpmem, grub_uint32_t index, grub_uint32_t memtype)
+{
+  grub_uint64_t tempmemsize = 0;
+  grub_uint32_t j = 0;
+  grub_uint32_t t = 0;
+
+  for(j = 0; j < length;)
+  {
+    tempmemsize = array[j].memsize;
+    for(t = j + 1; t < length; t++)
+    {
+      if(array[j].memstart + tempmemsize == array[t].memstart)
+      {
+        tempmemsize += array[t].memsize;
+      }
+      else
+      {
+        break;
+      }
+   }
+   bpmem->map[index].memtype = memtype;
+   bpmem->map[index].memstart = array[j].memstart;
+   bpmem->map[index].memsize = tempmemsize;
+   bpmem->map[index].attr = array[j].attr;
+   grub_dprintf("loongson", "v3 map[%d]:type %x, start 0x%llx, end 0x%llx, attr:0x%llx\n",
+		   index,
+		   bpmem->map[index].memtype,
+		   bpmem->map[index].memstart,
+		   bpmem->map[index].memstart+ bpmem->map[index].memsize,
+		   bpmem->map[index].attr
+	       );
+   j = t;
+   index++;
+  }
+  return index;
+}
+
diff --git a/grub-core/lib/loongarch64/efi/loongson_asm.S b/grub-core/lib/loongarch64/efi/loongson_asm.S
deleted file mode 100644
index 4a04d34..0000000
--- a/grub-core/lib/loongarch64/efi/loongson_asm.S
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2017  Free Software Foundation, Inc.
- *
- *  GRUB is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  GRUB is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <grub/symbol.h>
-
-	.file 	"loongson_asm.S"
-	.text
-
-	.align		4
-
-VARIABLE (grub_efi_loongson_reset_start)
-
-VARIABLE (grub_efi_loongson_reset_system_addr)
-	.dword		0
-
-reset_system:
-	bl		1f
-	move		$a1, $zero
-1:
-	ld.d		$t8, $ra, -16
-	move		$a2, $zero
-	jr		$t8
-	move		$a3, $zero
-
-FUNCTION(grub_efi_loongson_reset_cold)
-	b		reset_system
-	li.w	$a0, 0
-
-FUNCTION(grub_efi_loongson_reset_warm)
-	b		reset_system
-	li.w	$a0, 1
-
-FUNCTION(grub_efi_loongson_reset_shutdown)
-	b		reset_system
-	li.w	$a0, 2
-
-FUNCTION(grub_efi_loongson_reset_suspend)
-	b		reset_system
-	li.w	$a0, 3
-
-VARIABLE (grub_efi_loongson_reset_end)
-
-
diff --git a/grub-core/lib/loongarch64/relocator.c b/grub-core/lib/loongarch64/relocator.c
index f6c1b01..14bed46 100644
--- a/grub-core/lib/loongarch64/relocator.c
+++ b/grub-core/lib/loongarch64/relocator.c
@@ -147,6 +147,10 @@ grub_relocator64_boot (struct grub_relocator *rel,
 
   grub_arch_sync_caches ((void *) relst, relsize);
 
+  asm volatile (
+                 "ibar 0 \n"
+                 "dbar 0 \n");
+
   grub_uint64_t val;
   __asm__ __volatile__(
 		  "li.w    %0, 0x4\n\t"
diff --git a/grub-core/loader/loongarch64/linux.c b/grub-core/loader/loongarch64/linux.c
index c769bb2..e4aaf7b 100644
--- a/grub-core/loader/loongarch64/linux.c
+++ b/grub-core/loader/loongarch64/linux.c
@@ -56,9 +56,6 @@ static grub_off_t initrd_addr_arg_off;
 static int initrd_loaded = 0;
 
 
-static grub_uint32_t j = 0;
-static grub_uint32_t t = 0;
-grub_uint64_t tempMemsize = 0;
 grub_uint32_t free_index = 0;
 grub_uint32_t reserve_index = 0;
 grub_uint32_t acpi_table_index = 0;
@@ -70,6 +67,15 @@ page_align (grub_size_t size)
   return (size + (1 << 12) - 1) & (~((1 << 12) - 1));
 }
 
+static inline grub_uint64_t
+grub_efi_max_usable_address(void)
+{
+  grub_uint64_t addr;
+  asm volatile ("csrrd %0, 0x181" : "=r" (addr));
+  grub_dprintf("loongson", "max usable addr 0x%llx\n", addr);
+  return addr |= 0xffffffffffUL;
+}
+
 /* Find the optimal number of pages for the memory map. Is it better to
    move this code to efi/mm.c?  */
 static grub_efi_uintn_t
@@ -130,59 +136,76 @@ grub_linux_boot (void)
   state.gpr[5] = (grub_addr_t) linux_args_addr;
   grub_dprintf("loongson", "args_addr is %p\n", state.gpr[5]);
 
-  if(grub_efi_is_loongson ())
   {
     grub_efi_uintn_t mmap_size;
     grub_efi_uintn_t desc_size;
+    grub_efi_uint32_t desc_version;
     grub_efi_memory_descriptor_t *mmap_buf;
     grub_err_t err;
-    struct bootparamsinterface * boot_params;
+    struct boot_params_interface * boot_params;
     void * tmp_boot_params = NULL;
-    grub_efi_uint8_t new_interface_flag = 0;
-    mem_map * new_interface_mem = NULL;
-    char *p = NULL;
-
-    struct memmap reserve_mem[GRUB_EFI_LOONGSON_MMAP_MAX];
-    struct memmap free_mem[GRUB_EFI_LOONGSON_MMAP_MAX];
-    struct memmap acpi_table_mem[GRUB_EFI_LOONGSON_MMAP_MAX];
-    struct memmap acpi_nvs_mem[GRUB_EFI_LOONGSON_MMAP_MAX];
-
-    grub_memset(reserve_mem, 0, sizeof(struct memmap) * GRUB_EFI_LOONGSON_MMAP_MAX);
-    grub_memset(free_mem, 0, sizeof(struct memmap) * GRUB_EFI_LOONGSON_MMAP_MAX);
-    grub_memset(acpi_table_mem, 0, sizeof(struct memmap) * GRUB_EFI_LOONGSON_MMAP_MAX);
-    grub_memset(acpi_nvs_mem, 0, sizeof(struct memmap) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    mem_map_v1 * mem_map_v1_table = NULL;
+    mem_map_v3 * mem_map_v3_table = NULL;
+    int bpi_version = 0;
+
+    struct memmap_v1 reserve_mem_v1[GRUB_EFI_LOONGSON_MMAP_MAX];
+    struct memmap_v1 free_mem_v1[GRUB_EFI_LOONGSON_MMAP_MAX];
+    struct memmap_v1 acpi_table_mem_v1[GRUB_EFI_LOONGSON_MMAP_MAX];
+    struct memmap_v1 acpi_nvs_mem_v1[GRUB_EFI_LOONGSON_MMAP_MAX];
+    struct memmap_v3 reserve_mem_v3[GRUB_EFI_LOONGSON_MMAP_MAX];
+    struct memmap_v3 free_mem_v3[GRUB_EFI_LOONGSON_MMAP_MAX];
+    struct memmap_v3 acpi_table_mem_v3[GRUB_EFI_LOONGSON_MMAP_MAX];
+    struct memmap_v3 acpi_nvs_mem_v3[GRUB_EFI_LOONGSON_MMAP_MAX];
+
+    grub_memset(reserve_mem_v1, 0, sizeof(struct memmap_v1) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    grub_memset(free_mem_v1, 0, sizeof(struct memmap_v1) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    grub_memset(acpi_table_mem_v1, 0, sizeof(struct memmap_v1) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    grub_memset(acpi_nvs_mem_v1, 0, sizeof(struct memmap_v1) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    grub_memset(reserve_mem_v3, 0, sizeof(struct memmap_v3) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    grub_memset(free_mem_v3, 0, sizeof(struct memmap_v3) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    grub_memset(acpi_table_mem_v3, 0, sizeof(struct memmap_v3) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    grub_memset(acpi_nvs_mem_v3, 0, sizeof(struct memmap_v3) * GRUB_EFI_LOONGSON_MMAP_MAX);
 
     tmp_boot_params = grub_efi_loongson_get_boot_params();
-    if(tmp_boot_params == NULL)
+    if (tmp_boot_params == NULL)
     {
-      grub_printf("not find param\n");
-      return -1;
-    }
+      grub_int8_t signature[8] = {'B','P','I','0','1','0','0','2'};
+      boot_params = grub_efi_allocate_pages_real (grub_efi_max_usable_address(),
+				       page_align (64 * 1024) >> 12, GRUB_EFI_ALLOCATE_MAX_ADDRESS,
+				       GRUB_EFI_RUNTIME_SERVICES_DATA);
+      grub_dprintf("loongson", "create bpi, boot_params is %p\n", boot_params);
+      if (! boot_params)
+        return grub_error (GRUB_ERR_IO, "cannot allocate boot params ");
+
+      memcpy(&boot_params->signature, signature, sizeof(grub_uint64_t));
+      boot_params->extlist_offset = sizeof(*boot_params);
+      boot_params->flags = 1 << FLAGS_EFI_SUPPORT_BIT;
+      boot_params->systemtable = grub_efi_system_table;
+
+      mem_map_v3_table = (mem_map_v3 *)((char *)boot_params + boot_params->extlist_offset);
+      memset(&mem_map_v3_table->header, 0, sizeof(struct _extention_list_hdr));
+      memcpy(&mem_map_v3_table->header.signature, "MEM", sizeof(grub_uint64_t));
+      mem_map_v3_table->header.revision = 0;
+      mem_map_v3_table->header.length = sizeof(*mem_map_v3_table);
+    } else {
+      boot_params = (struct boot_params_interface *)tmp_boot_params;
 
-    boot_params = (struct bootparamsinterface *)tmp_boot_params;
-    p = (char *)&(boot_params->signature);
-    if(grub_strncmp(p, "BPI", 3) == 0)
-    {
-      /* Check extlist headers */
       ext_list * listpointer = NULL;
+      /* Check extlist headers */
       listpointer = boot_params->extlist;
       for( ;listpointer != NULL; listpointer = listpointer->next)
       {
         char *pl= (char *)&(listpointer->signature);
         if(grub_strncmp(pl, "MEM", 3) == 0)
         {
-          new_interface_mem = (mem_map *)listpointer;
+          mem_map_v1_table = (mem_map_v1 *)listpointer;
+          break;
         }
       }
-
-      new_interface_flag = 1;
-      grub_dprintf("loongson", "get new parameter interface\n");
-    }else{
-      new_interface_flag = 0;
-      grub_dprintf("loongson", "get old parameter interface\n");
     }
-    state.gpr[6] = (grub_uint64_t)tmp_boot_params;
-    grub_dprintf("loongson", "boot_params is %p\n", state.gpr[6]);
+
+    grub_dprintf("loongson", "boot_params is %p\n", boot_params);
+    state.gpr[6] = (grub_uint64_t)boot_params;
 
     mmap_size = find_mmap_size ();
     if (! mmap_size)
@@ -191,100 +214,156 @@ grub_linux_boot (void)
     if (! mmap_buf)
       return grub_error (GRUB_ERR_IO, "cannot allocate memory map");
     err = grub_efi_finish_boot_services (&mmap_size, mmap_buf, NULL,
-                                         &desc_size, NULL);
+                                         &desc_size, &desc_version);
     if (err)
       return err;
 
-    if(new_interface_flag)
-    {
-      if (!mmap_buf || !mmap_size || !desc_size)
-        return -1;
-      tmp_index = new_interface_mem -> mapcount;
+    if (!mmap_buf || !mmap_size || !desc_size)
+      return -1;
+
+    char *p = (char *)&(boot_params->signature);
+    bpi_version = grub_efi_get_bpi_version(p);
+    grub_dprintf("loongson", "get bpi version:%d\n", bpi_version);
 
+    if (bpi_version <= GRUB_EFI_BPI_VER_V2)
+    {
       /*
-       According to UEFI SPEC,mmap_buf is the accurate Memory Map array \
-       now we can fill platform specific memory structure.
-       */
+      According to UEFI SPEC,mmap_buf is the accurate Memory Map array \
+      now we can fill platform specific memory structure.
+      */
       for(lsdesc = mmap_buf; lsdesc < (grub_efi_memory_descriptor_t *)((char *)mmap_buf + mmap_size);
-                lsdesc = (grub_efi_memory_descriptor_t *)((char *)lsdesc + desc_size))
+            lsdesc = (grub_efi_memory_descriptor_t *)((char *)lsdesc + desc_size))
       {
-        /* Recovery */
-        if((lsdesc->type != GRUB_EFI_ACPI_RECLAIM_MEMORY) && \
-           (lsdesc->type != GRUB_EFI_ACPI_MEMORY_NVS) && \
-           (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_DATA) && \
-           (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_CODE) && \
-           (lsdesc->type != GRUB_EFI_RESERVED_MEMORY_TYPE) && \
-           (lsdesc->type != GRUB_EFI_PAL_CODE))
+        grub_dprintf("loongson", "type:%d, phy_start:0x%llx, phy_end:0x%llx\n", lsdesc->type,
+          lsdesc->physical_start, lsdesc->physical_start + lsdesc->num_pages*4096);
+
+        /* System RAM */
+        if ((lsdesc->type != GRUB_EFI_ACPI_RECLAIM_MEMORY) && \
+            (lsdesc->type != GRUB_EFI_ACPI_MEMORY_NVS) && \
+            (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_DATA) && \
+            (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_CODE) && \
+            (lsdesc->type != GRUB_EFI_RESERVED_MEMORY_TYPE) && \
+            (lsdesc->type != GRUB_EFI_PAL_CODE))
         {
-          free_mem[free_index].memtype = GRUB_EFI_LOONGSON_SYSTEM_RAM;
-          free_mem[free_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          free_mem[free_index].memsize = lsdesc->num_pages * 4096;
+          free_mem_v1[free_index].memtype = GRUB_EFI_LOONGSON_SYSTEM_RAM;
+          free_mem_v1[free_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          free_mem_v1[free_index].memsize = lsdesc->num_pages * 4096;
           free_index++;
 
         /*ACPI*/
-        }else if((lsdesc->type == GRUB_EFI_ACPI_RECLAIM_MEMORY)){
-          acpi_table_mem[acpi_table_index].memtype = GRUB_EFI_LOONGSON_ACPI_TABLE;
-          acpi_table_mem[acpi_table_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          acpi_table_mem[acpi_table_index].memsize = lsdesc->num_pages * 4096;
+        } else if ((lsdesc->type == GRUB_EFI_ACPI_RECLAIM_MEMORY)){
+          acpi_table_mem_v1[acpi_table_index].memtype = GRUB_EFI_LOONGSON_ACPI_TABLE;
+          acpi_table_mem_v1[acpi_table_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          acpi_table_mem_v1[acpi_table_index].memsize = lsdesc->num_pages * 4096;
           acpi_table_index++;
-        }else if((lsdesc->type == GRUB_EFI_ACPI_MEMORY_NVS)){
-          acpi_nvs_mem[acpi_nvs_index].memtype = GRUB_EFI_LOONGSON_ACPI_NVS;
-          acpi_nvs_mem[acpi_nvs_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          acpi_nvs_mem[acpi_nvs_index].memsize = lsdesc->num_pages * 4096;
+        } else if ((lsdesc->type == GRUB_EFI_ACPI_MEMORY_NVS)){
+          acpi_nvs_mem_v1[acpi_nvs_index].memtype = GRUB_EFI_LOONGSON_ACPI_NVS;
+          acpi_nvs_mem_v1[acpi_nvs_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          acpi_nvs_mem_v1[acpi_nvs_index].memsize = lsdesc->num_pages * 4096;
           acpi_nvs_index++;
 
         /* Reserve */
-        }else{
-          reserve_mem[reserve_index].memtype = GRUB_EFI_LOONGSON_MEMORY_RESERVED;
-          reserve_mem[reserve_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
-          reserve_mem[reserve_index].memsize = lsdesc->num_pages * 4096;
+        } else {
+          reserve_mem_v1[reserve_index].memtype = GRUB_EFI_LOONGSON_MEMORY_RESERVED;
+          reserve_mem_v1[reserve_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          reserve_mem_v1[reserve_index].memsize = lsdesc->num_pages * 4096;
           reserve_index++;
         }
       }
 
-      /* Recovery sort */
-      for(j = 0; j < free_index;)
+      tmp_index = mem_map_v1_table->mapcount;
+      /*System RAM Sort*/
+      tmp_index = grub_efi_loongson_memmap_v1_sort(free_mem_v1, free_index, mem_map_v1_table,
+                          tmp_index, GRUB_EFI_LOONGSON_SYSTEM_RAM);
+      /*ACPI Sort*/
+      tmp_index = grub_efi_loongson_memmap_v1_sort(acpi_table_mem_v1, acpi_table_index,
+                    mem_map_v1_table, tmp_index, GRUB_EFI_LOONGSON_ACPI_TABLE);
+      tmp_index = grub_efi_loongson_memmap_v1_sort(acpi_nvs_mem_v1, acpi_nvs_index,
+                    mem_map_v1_table, tmp_index, GRUB_EFI_LOONGSON_ACPI_NVS);
+      /*Reserve Sort*/
+      grub_uint64_t loongarch_addr;
+      asm volatile ("csrrd %0, 0x181" : "=r" (loongarch_addr));
+      if ((loongarch_addr & 0xff00000000000000) == 0x9000000000000000){
+        tmp_index = grub_efi_loongson_memmap_v1_sort(reserve_mem_v1, reserve_index, mem_map_v1_table,
+                      tmp_index, GRUB_EFI_LOONGSON_MEMORY_RESERVED);
+      } else {
+        tmp_index = grub_efi_loongson_memmap_v1_sort(reserve_mem_v1, reserve_index, mem_map_v1_table,
+                      tmp_index, GRUB_EFI_LOONGSON_MEMORY_RESERVED + 1);
+      }
+
+      mem_map_v1_table->mapcount = tmp_index;
+      mem_map_v1_table->header.checksum = 0;
+
+      checksum = grub_efi_loongson_grub_calculatechecksum8(mem_map_v1_table, mem_map_v1_table->header.length);
+      mem_map_v1_table->header.checksum = checksum;
+
+    } else {
+      /*
+      According to UEFI SPEC,mmap_buf is the accurate Memory Map array \
+      now we can fill platform specific memory structure.
+      */
+      for(lsdesc = mmap_buf; lsdesc < (grub_efi_memory_descriptor_t *)((char *)mmap_buf + mmap_size);
+            lsdesc = (grub_efi_memory_descriptor_t *)((char *)lsdesc + desc_size))
       {
-        tempMemsize = free_mem[j].memsize;
-        for(t = j + 1; t < free_index; t++)
+        grub_dprintf("loongson", "type:%d, phy_start:0x%llx, phy_end:0x%llx, attribute:0x%llx\n", lsdesc->type,
+          lsdesc->physical_start, lsdesc->physical_start + lsdesc->num_pages*4096, lsdesc->attribute);
+
+        /* System RAM */
+        if ((lsdesc->type != GRUB_EFI_ACPI_RECLAIM_MEMORY) && \
+            (lsdesc->type != GRUB_EFI_ACPI_MEMORY_NVS) && \
+            (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_DATA) && \
+            (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_CODE) && \
+            (lsdesc->type != GRUB_EFI_RESERVED_MEMORY_TYPE) && \
+            (lsdesc->type != GRUB_EFI_PAL_CODE))
         {
-          if((free_mem[j].memstart + tempMemsize == free_mem[t].memstart) && (free_mem[j].memtype == free_mem[t].memtype))
-          {
-            tempMemsize += free_mem[t].memsize;
-          }else{
-            break;
-          }
-        }
+          free_mem_v3[free_index].memtype = GRUB_EFI_LOONGSON_SYSTEM_RAM;
+          free_mem_v3[free_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          free_mem_v3[free_index].memsize = lsdesc->num_pages * 4096;
+          free_mem_v3[free_index].attr = lsdesc->attribute;
+          free_index++;
 
-        new_interface_mem->map[tmp_index].memtype = GRUB_EFI_LOONGSON_SYSTEM_RAM;
-        new_interface_mem->map[tmp_index].memstart = free_mem[j].memstart;
-        new_interface_mem->map[tmp_index].memsize = tempMemsize;
-        grub_dprintf("loongson", "map[%d]:type %x, start 0x%llx, end 0x%llx\n",
-                     tmp_index,
-                     new_interface_mem->map[tmp_index].memtype,
-                     new_interface_mem->map[tmp_index].memstart,
-                     new_interface_mem->map[tmp_index].memstart+ new_interface_mem->map[tmp_index].memsize
-                    );
-        j = t;
-        tmp_index++;
+        /*ACPI*/
+        } else if ((lsdesc->type == GRUB_EFI_ACPI_RECLAIM_MEMORY)){
+          acpi_table_mem_v3[acpi_table_index].memtype = GRUB_EFI_LOONGSON_ACPI_TABLE;
+          acpi_table_mem_v3[acpi_table_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          acpi_table_mem_v3[acpi_table_index].memsize = lsdesc->num_pages * 4096;
+          acpi_table_mem_v3[acpi_table_index].attr = lsdesc->attribute;
+          acpi_table_index++;
+        } else if ((lsdesc->type == GRUB_EFI_ACPI_MEMORY_NVS)){
+          acpi_nvs_mem_v3[acpi_nvs_index].memtype = GRUB_EFI_LOONGSON_ACPI_NVS;
+          acpi_nvs_mem_v3[acpi_nvs_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          acpi_nvs_mem_v3[acpi_nvs_index].memsize = lsdesc->num_pages * 4096;
+          acpi_nvs_mem_v3[acpi_nvs_index].attr = lsdesc->attribute;
+          acpi_nvs_index++;
+
+        /* Reserve */
+        } else {
+          reserve_mem_v3[reserve_index].memtype = GRUB_EFI_LOONGSON_MEMORY_RESERVED;
+          reserve_mem_v3[reserve_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          reserve_mem_v3[reserve_index].memsize = lsdesc->num_pages * 4096;
+          reserve_mem_v3[reserve_index].attr = lsdesc->attribute;
+          reserve_index++;
+        }
       }
+
+      /*System RAM Sort*/
+      tmp_index = grub_efi_loongson_memmap_v3_sort(free_mem_v3, free_index, mem_map_v3_table,
+                          tmp_index, GRUB_EFI_LOONGSON_SYSTEM_RAM);
       /*ACPI Sort*/
-      tmp_index = grub_efi_loongson_memmap_sort(acpi_table_mem, acpi_table_index, new_interface_mem, tmp_index, GRUB_EFI_LOONGSON_ACPI_TABLE);
-      tmp_index = grub_efi_loongson_memmap_sort(acpi_nvs_mem, acpi_nvs_index, new_interface_mem, tmp_index, GRUB_EFI_LOONGSON_ACPI_NVS);
+      tmp_index = grub_efi_loongson_memmap_v3_sort(acpi_table_mem_v3, acpi_table_index,
+                    mem_map_v3_table, tmp_index, GRUB_EFI_LOONGSON_ACPI_TABLE);
+      tmp_index = grub_efi_loongson_memmap_v3_sort(acpi_nvs_mem_v3, acpi_nvs_index,
+                    mem_map_v3_table, tmp_index, GRUB_EFI_LOONGSON_ACPI_NVS);
       /*Reserve Sort*/
-	  grub_uint64_t loongarch_addr;
-	  asm volatile ("csrrd %0, 0x181" : "=r" (loongarch_addr));
-	  if((loongarch_addr & 0xff00000000000000) == 0x9000000000000000){
-        tmp_index = grub_efi_loongson_memmap_sort(reserve_mem, reserve_index, new_interface_mem, tmp_index, GRUB_EFI_LOONGSON_MEMORY_RESERVED);
-	  }else{
-        tmp_index = grub_efi_loongson_memmap_sort(reserve_mem, reserve_index, new_interface_mem, tmp_index, GRUB_EFI_LOONGSON_MEMORY_RESERVED + 1);
-	  }
-
-      new_interface_mem->mapcount = tmp_index;
-      new_interface_mem->header.checksum = 0;
-
-      checksum = grub_efi_loongson_grub_calculatechecksum8(new_interface_mem, new_interface_mem->header.length);
-      new_interface_mem->header.checksum = checksum;
+      tmp_index = grub_efi_loongson_memmap_v3_sort(reserve_mem_v3, reserve_index,
+                    mem_map_v3_table, tmp_index, GRUB_EFI_LOONGSON_MEMORY_RESERVED);
+
+      mem_map_v3_table->mapcount = tmp_index;
+      mem_map_v3_table->descver = desc_version;
+      mem_map_v3_table->header.checksum = 0;
+
+      checksum = grub_efi_loongson_grub_calculatechecksum8(mem_map_v3_table, mem_map_v3_table->header.length);
+      mem_map_v3_table->header.checksum = checksum;
     }
   }
 
@@ -345,6 +424,8 @@ grub_linux_load64 (grub_elf_t elf, const char *filename)
   Elf64_Addr base;
   grub_err_t err;
   grub_uint8_t *playground;
+  grub_uint64_t addr;
+  int flag;
 
   /* Linux's entry point incorrectly contains a virtual address.  */
   entry_addr = elf->ehdr.ehdr64.e_entry;
@@ -358,8 +439,16 @@ grub_linux_load64 (grub_elf_t elf, const char *filename)
   target_addr = base;
   linux_size = ALIGN_UP (base + linux_size - base, 8);
 
+  asm volatile ("csrrd %0, 0x181" : "=r" (addr));
+  if (addr & 0x1) {
+    flag = GRUB_ELF_LOAD_FLAGS_NONE;
+  } else {
+    flag = GRUB_ELF_LOAD_FLAGS_30BITS;
+    base &= ~ELF64_LOADMASK;
+    entry_addr &= ~ELF64_LOADMASK;
+  }
+
   relocator = grub_relocator_new ();
- //   linux_size=0x322fa80;
   if (!relocator)
     return grub_errno;
 
@@ -374,7 +463,7 @@ grub_linux_load64 (grub_elf_t elf, const char *filename)
   }
 
   /* Now load the segments into the area we claimed.  */
-  return grub_elf64_load (elf, filename, playground - base, GRUB_ELF_LOAD_FLAGS_NONE, 0, 0);
+  return grub_elf64_load (elf, filename, playground - base, flag, 0, 0);
 }
 
 static grub_err_t
@@ -410,7 +499,7 @@ grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
   linux_argc = argc;
   /* Main arguments.  */
   size = (linux_argc) * sizeof (grub_uint64_t);
-  /* Initrd address and size.  */
+  /* Initrd address/size and initrd  */
   size += 3 * sizeof (grub_uint64_t);
   /* NULL terminator.  */
   size += sizeof (grub_uint64_t);
diff --git a/include/grub/loongarch64/efi/loongson.h b/include/grub/loongarch64/efi/loongson.h
index fa32ef5..6668d08 100644
--- a/include/grub/loongarch64/efi/loongson.h
+++ b/include/grub/loongarch64/efi/loongson.h
@@ -23,7 +23,7 @@
 
 #include <grub/efi/api.h>
 
-#define GRUB_EFI_LOONGSON_SMBIOS_TABLE_GUID	\
+#define GRUB_EFI_LOONGSON_BPI_TABLE_GUID	\
   { 0x4660f721, 0x2ec5, 0x416a, \
     { 0x89, 0x9a, 0x43, 0x18, 0x02, 0x50, 0xa0, 0xc9 } \
   }
@@ -39,252 +39,93 @@ typedef enum
   }
 grub_efi_loongson_memory_type;
 
-typedef struct
-{
-  grub_uint16_t vers;     /* version */
-  grub_uint32_t nr_map;   /* number of memory_maps */
-  grub_uint32_t mem_freq; /* memory frequence */
-  struct mem_map {
-    grub_uint32_t node_id;        /* node_id which memory attached to */
-    grub_uint32_t mem_type;       /* system memory, pci memory, pci io, etc. */
-    grub_uint64_t mem_start;      /* memory map start address */
-    grub_uint32_t mem_size;       /* each memory_map size, not the total size */
-  } map[GRUB_EFI_LOONGSON_MMAP_MAX];
-} GRUB_PACKED
-grub_efi_loongson_memory_map;
-
-/*
- * Capability and feature descriptor structure for LOONGARCH CPU
- */
-typedef struct
-{
-  grub_uint16_t vers;         /* version */
-  grub_uint32_t processor_id; /* PRID, e.g. 6305, 6306 */
-  grub_uint32_t cputype;      /* Loongson_3A/3B, etc. */
-  grub_uint32_t total_node;   /* num of total numa nodes */
-  grub_uint16_t cpu_startup_core_id; /* Boot core id */
-  grub_uint16_t reserved_cores_mask;
-  grub_uint32_t cpu_clock_freq; /* cpu_clock */
-  grub_uint32_t nr_cpus;
-} GRUB_PACKED
-grub_efi_loongson_cpu_info;
-
-#define GRUB_EFI_LOONGSON_MAX_UARTS 64
-
-typedef struct
-{
-  grub_uint32_t iotype; /* see include/linux/serial_core.h */
-  grub_uint32_t uartclk;
-  grub_uint32_t int_offset;
-  grub_uint64_t uart_base;
-} GRUB_PACKED
-grub_efi_loongson_uart_device;
-
-#define GRUB_EFI_LOONGSON_MAX_SENSORS 64
-
-typedef struct
-{
-  char name[32];   /* a formal name */
-  char label[64];  /* a flexible description */
-  grub_uint32_t type;        /* SENSOR_* */
-  grub_uint32_t id;          /* instance id of a sensor-class */
-  grub_uint32_t fan_policy;
-  grub_uint32_t fan_percent; /* only for constant speed policy */
-  grub_uint64_t base_addr;   /* base address of device registers */
-} GRUB_PACKED
-grub_efi_loongson_sensor_device;
-
-typedef struct
-{
-  grub_uint16_t vers;     /* version */
-  grub_uint32_t ccnuma_smp; /* 0: no numa; 1: has numa */
-  grub_uint32_t sing_double_channel; /* 1:single; 2:double */
-  grub_uint32_t nr_uarts;
-  grub_efi_loongson_uart_device uarts[GRUB_EFI_LOONGSON_MAX_UARTS];
-  grub_uint32_t nr_sensors;
-  grub_efi_loongson_sensor_device sensors[GRUB_EFI_LOONGSON_MAX_SENSORS];
-  char has_ec;
-  char ec_name[32];
-  grub_uint64_t ec_base_addr;
-  char has_tcm;
-  char tcm_name[32];
-  grub_uint64_t tcm_base_addr;
-  grub_uint64_t workarounds; /* see workarounds.h */
-} GRUB_PACKED
-grub_efi_loongson_system_info;
-
-typedef struct
-{
-  grub_uint16_t vers;
-  grub_uint16_t size;
-  grub_uint16_t rtr_bus;
-  grub_uint16_t rtr_devfn;
-  grub_uint32_t vendor;
-  grub_uint32_t device;
-  grub_uint32_t PIC_type;   /* conform use HT or PCI to route to CPU-PIC */
-  grub_uint64_t ht_int_bit; /* 3A: 1<<24; 3B: 1<<16 */
-  grub_uint64_t ht_enable;  /* irqs used in this PIC */
-  grub_uint32_t node_id;    /* node id: 0x0-0; 0x1-1; 0x10-2; 0x11-3 */
-  grub_uint64_t pci_mem_start_addr;
-  grub_uint64_t pci_mem_end_addr;
-  grub_uint64_t pci_io_start_addr;
-  grub_uint64_t pci_io_end_addr;
-  grub_uint64_t pci_config_addr;
-  grub_uint32_t dma_mask_bits;
-} GRUB_PACKED
-grub_efi_loongson_irq_src_routing_table;
-
-typedef struct
-{
-  grub_uint16_t vers; /* version */
-  grub_uint16_t size;
-  grub_uint8_t  flag;
-  char description[64];
-} GRUB_PACKED
-grub_efi_loongson_interface_info;
-
-#define GRUB_EFI_LOONGSON_MAX_RESOURCE_NUMBER 128
-
-typedef struct
-{
-  grub_uint64_t start; /* resource start address */
-  grub_uint64_t end;   /* resource end address */
-  char name[64];
-  grub_uint32_t flags;
-}
-grub_efi_loongson_resource;
-
-/* arch specific additions */
-typedef struct
-{
-}
-grub_efi_loongson_archdev_data;
-
-typedef struct
-{
-  char name[64];    /* hold the device name */
-  grub_uint32_t num_resources; /* number of device_resource */
-  /* for each device's resource */
-  grub_efi_loongson_resource resource[GRUB_EFI_LOONGSON_MAX_RESOURCE_NUMBER];
-  /* arch specific additions */
-  grub_efi_loongson_archdev_data archdata;
-}
-grub_efi_loongson_board_devices;
-
-typedef struct
-{
-  grub_uint16_t vers;     /* version */
-  char special_name[64]; /* special_atribute_name */
-  grub_uint32_t loongson_special_type; /* type of special device */
-  /* for each device's resource */
-  grub_efi_loongson_resource resource[GRUB_EFI_LOONGSON_MAX_RESOURCE_NUMBER];
-}
-grub_efi_loongson_special_attribute;
-
-typedef struct
-{
-  grub_uint64_t memory_offset;    /* efi_loongson_memory_map struct offset */
-  grub_uint64_t cpu_offset;       /* efi_loongson_cpuinfo struct offset */
-  grub_uint64_t system_offset;    /* efi_loongson_system_info struct offset */
-  grub_uint64_t irq_offset;       /* efi_loongson_irq_src_routing_table struct offset */
-  grub_uint64_t interface_offset; /* interface_info struct offset */
-  grub_uint64_t special_offset;   /* efi_loongson_special_attribute struct offset */
-  grub_uint64_t boarddev_table_offset;  /* efi_loongson_board_devices offset */
-}
-grub_efi_loongson_params;
-
-typedef struct
-{
-  grub_uint16_t vers;     /* version */
-  grub_uint64_t vga_bios; /* vga_bios address */
-  grub_efi_loongson_params lp;
-}
-grub_efi_loongson_smbios_table;
-
-typedef struct
-{
-  grub_uint64_t reset_cold;
-  grub_uint64_t reset_warm;
-  grub_uint64_t reset_type;
-  grub_uint64_t shutdown;
-  grub_uint64_t do_suspend; /* NULL if not support */
-}
-grub_efi_loongson_reset_system;
-
-typedef struct
-{
-  grub_uint64_t mps;    /* MPS table */
-  grub_uint64_t acpi;   /* ACPI table (IA64 ext 0.71) */
-  grub_uint64_t acpi20; /* ACPI table (ACPI 2.0) */
-  grub_efi_loongson_smbios_table smbios; /* SM BIOS table */
-  grub_uint64_t sal_systab; /* SAL system table */
-  grub_uint64_t boot_info;  /* boot info table */
-}
-grub_efi_loongson;
-
-typedef struct
-{
-  grub_efi_loongson efi;
-  grub_efi_loongson_reset_system reset_system;
-}
-grub_efi_loongson_boot_params;
-
-extern grub_uint64_t grub_efi_loongson_reset_system_addr;
-
-extern void grub_efi_loongson_reset_cold (void);
-extern void grub_efi_loongson_reset_warm (void);
-extern void grub_efi_loongson_reset_shutdown (void);
-extern void grub_efi_loongson_reset_suspend (void);
-
-void grub_efi_loongson_alloc_boot_params (void);
-void grub_efi_loongson_free_boot_params (void);
-void * grub_efi_loongson_get_smbios_table (void);
-
-int EXPORT_FUNC(grub_efi_is_loongson) (void);
+typedef enum
+   {
+     GRUB_EFI_BPI_VER_NONE = 0,
+     GRUB_EFI_BPI_VER_V1 = 1000,
+     GRUB_EFI_BPI_VER_V2 = 1001,
+     GRUB_EFI_BPI_VER_V3 = 1002,
+   }
+ grub_efi_loongson_bpi_version;
+
+#define ELF32_LOADMASK (0xf0000000UL)
+#define ELF64_LOADMASK (0xf000000000000000ULL)
+#define FLAGS_EFI_SUPPORT_BIT 0
 
 grub_uint8_t
-EXPORT_FUNC(grub_efi_loongson_calculatesum8) (const grub_uint8_t *Buffer, grub_efi_uintn_t Length);
+EXPORT_FUNC(grub_efi_loongson_calculatesum8) (const grub_uint8_t *Buffer,
+                                              grub_efi_uintn_t Length);
 
 grub_uint8_t
-EXPORT_FUNC(grub_efi_loongson_grub_calculatechecksum8) (const grub_uint8_t *Buffer, grub_efi_uintn_t Length);
+EXPORT_FUNC(grub_efi_loongson_grub_calculatechecksum8) (const grub_uint8_t *Buffer,
+                                                       grub_efi_uintn_t Length);
 
+int EXPORT_FUNC(grub_efi_get_bpi_version) (const char *str);
 
 void *
 EXPORT_FUNC(grub_efi_loongson_get_boot_params) (void);
 
-typedef struct _extention_list_hdr{
+typedef struct _extention_list_hdr {
   grub_uint64_t  signature;
   grub_uint32_t  length;
   grub_uint8_t   revision;
   grub_uint8_t   checksum;
-  struct  _extention_list_hdr *next;
+  union {
+    struct  _extention_list_hdr *next;
+    grub_uint64_t  next_offset;
+  };
 }GRUB_PACKED
 ext_list;
 
-typedef struct bootparamsinterface {
-  grub_uint64_t           signature;    //{'B', 'P', 'I', '_', '0', '_', '1'}
+typedef struct boot_params_interface {
+  grub_uint64_t signature; //{'B', 'P', 'I', 'x', 'x', 'x', 'x', 'x'}
   grub_efi_system_table_t *systemtable;
-  ext_list         *extlist;
+  union {
+    ext_list *extlist;
+    grub_uint64_t  extlist_offset;
+  };
+  grub_uint64_t  flags;
+}GRUB_PACKED
+boot_params_interface;
+
+typedef struct {
+  ext_list  header; //{MEM}
+  grub_uint8_t mapcount;
+  struct GRUB_PACKED memmap_v1 {
+    grub_uint32_t memtype;
+    grub_uint64_t memstart;
+    grub_uint64_t memsize;
+  } map[GRUB_EFI_LOONGSON_MMAP_MAX];
 }GRUB_PACKED
-bootparamsinterface;
+mem_map_v1;
 
 typedef struct {
-  ext_list  header;         //  {'M', 'E', 'M'}
+  ext_list  header; //{MEM}
   grub_uint8_t mapcount;
-  struct GRUB_PACKED memmap {
+  grub_uint32_t descver;
+  struct GRUB_PACKED memmap_v3 {
     grub_uint32_t memtype;
+    grub_uint32_t pad;
     grub_uint64_t memstart;
+    grub_uint64_t virtstart;
     grub_uint64_t memsize;
+    grub_uint64_t attr;
   } map[GRUB_EFI_LOONGSON_MMAP_MAX];
 }GRUB_PACKED
-mem_map;
+mem_map_v3;
 
 typedef struct {
-  ext_list header;          // {VBIOS}
+  ext_list header; //{VBIOS}
   grub_uint64_t  vbiosaddr;
 }GRUB_PACKED
 vbios;
 
-grub_uint32_t 
-EXPORT_FUNC (grub_efi_loongson_memmap_sort) (struct memmap array[], grub_uint32_t length, mem_map * bpmem, grub_uint32_t index, grub_uint32_t memtype);
+grub_uint32_t
+EXPORT_FUNC (grub_efi_loongson_memmap_v1_sort) (struct memmap_v1 array[],
+                                grub_uint32_t length, mem_map_v1 * mem,
+                                grub_uint32_t index, grub_uint32_t memtype);
+grub_uint32_t
+EXPORT_FUNC (grub_efi_loongson_memmap_v3_sort) (struct memmap_v3 array[],
+                                grub_uint32_t length, mem_map_v3 * mem,
+                                grub_uint32_t index, grub_uint32_t memtype);
 #endif /* ! GRUB_EFI_LOONGSON_HEADER */
diff --git a/include/grub/loongarch64/memory.h b/include/grub/loongarch64/memory.h
index 03398b3..cc9faef 100644
--- a/include/grub/loongarch64/memory.h
+++ b/include/grub/loongarch64/memory.h
@@ -41,9 +41,11 @@ static inline void *
 grub_map_memory (grub_phys_addr_t a, grub_size_t size)
 {
   grub_uint64_t addr;
-
   asm volatile ("csrrd %0, 0x181" : "=r" (addr));
-  return (void *) (a | (addr & 0xffffffffffffff00UL));
+  if (addr & 0x1)
+    return (void *) (a | (addr & 0xffffffffffffff00UL));
+  else
+	return (void *) a;
 }
 
 static inline void
-- 
2.1.0

